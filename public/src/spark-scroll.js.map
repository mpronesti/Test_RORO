{"version":3,"sources":["spark-scroll.coffee"],"names":[],"mappings":"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","file":"spark-scroll.js","sourceRoot":"/source/","sourcesContent":["angular.module('gilbox.sparkScroll', [])\n\n# sparkAnimator can be overridden to use any animation engine\n# so long as the sparkAnimator service supports the following Rekapi-like\n# interface:\n#\n# actor = sparkAnimator.addActor({ context: <dom element> })  # works just like Rekapi.addActor(...)\n# actor.keyframe(...)\n# actor.moveKeyframe(...)\n# actor.removeAllKeyframes(...)\n# sparkAnimator.update(...)       # works just like Rekapi.update(...)\n#\n# See the Rekapi docs for implementation details   http://rekapi.com/dist/doc/\n.factory 'sparkAnimator', ['$document', ($document) ->\n  instance: ->\n    Rekapi && new Rekapi($document[0].body)\n]\n\n.constant 'sparkFormulas', {\n\n  # formulas are always in the format: variable or variable<offset>\n  #   (note that you cannot combine formula variables)\n  # for example:\n  #\n  #      topTop+40\n  #      topBottom-120\n  #      topCenter\n  #      centerTop\n  #      centerCenter-111\n  #\n  # are valid formulas. (topTop40 is valid as well but less intuitive)\n  #\n  # each property of the sparkFormulas object is a formula variable\n\n  # top of the element hits the top of the viewport\n  topTop: `function topTop(element, container, rect, containerRect, offset) { return ~~(rect.top - containerRect.top + offset) }`\n\n  # top of the element hits the center of the viewport\n  topCenter: `function topCenter(element, container, rect, containerRect, offset) { return ~~(rect.top - containerRect.top - container.clientHeight/2 + offset) }`\n\n  # top of the element hits the bottom of the viewport\n  topBottom: `function topBottom(element, container, rect, containerRect, offset) {  return ~~(rect.top - containerRect.top - container.clientHeight + offset) }`\n\n  # center of the element hits the top of the viewport\n  centerTop: `function centerTop(element, container, rect, containerRect, offset) { return ~~(rect.top + rect.height/2 - containerRect.top + offset) }`\n\n  # center of the element hits the center of the viewport\n  centerCenter: `function centerCenter(element, container, rect, containerRect, offset) { return ~~(rect.top + rect.height/2 - containerRect.top - container.clientHeight/2 + offset) }`\n\n  # center of the element hits the bottom of the viewport\n  centerBottom: `function centerBottom(element, container, rect, containerRect, offset) {  return ~~(rect.top + rect.height/2 - containerRect.top - container.clientHeight + offset) }`\n\n  # bottom of the element hits the top of the viewport\n  bottomTop: `function bottomTop(element, container, rect, containerRect, offset) { return ~~(rect.bottom - containerRect.top + offset) }`\n\n  # bottom of the element hits the bottom of the viewport\n  bottomBottom: `function bottomBottom(element, container, rect, containerRect, offset) { return ~~(rect.bottom - containerRect.top - container.clientHeight + offset) }`\n\n  # bottom of the element hits the center of the viewport\n  bottomCenter: `function bottomCenter(element, container, rect, containerRect, offset) { return ~~(rect.bottom - containerRect.top - container.clientHeight/2 + offset) }`\n}\n\n.constant 'sparkActionProps', {\n\n  # When the up, down fns are called, `this` is the current keyFrame object and `o` is the action object\n  # therefore @element and @scope refer to the current element and it's scope\n\n  # fn reference that is called when scrolled down past keyframe\n  'onDown':\n    down: (o)-> if _.isString(o.val) then @scope.$eval(o.val)(@, 'onDown', o) else o.val(@, 'onDown', o)\n\n  # fn reference that is called when scrolled up past keyframe\n  'onUp':\n    up: (o)-> if _.isString(o.val) then @scope.$eval(o.val)(@, 'onUp', o) else o.val(@, 'onUp', o)\n\n  # class(es) added when scrolled down past keyframe,\n  'downAddClass':\n    down: (o)-> @element.addClass(o.val)\n\n  # class(es) added when scrolled up past keyframe,\n  'upAddClass':\n    up: (o)-> @element.addClass(o.val)\n\n  # class(es) removed when scrolled down past keyframe\n  'downRemoveClass':\n    down: (o)-> @element.removeClass(o.val)\n\n  # class(es) removed when scrolled up past keyframe\n  'upRemoveClass':\n    up: (o)-> @element.removeClass(o.val)\n\n  # broadcasts an event when scrolled down past keyframe\n  'downBroadcast':\n    down: (o)-> @scope.$broadcast(o.val, @)\n\n  # broadcasts an event when scrolled up past keyframe\n  'upBroadcast':\n    up: (o)-> @scope.$broadcast(o.val, @)\n\n  # emits an event when scrolled down past keyframe\n  'downEmit':\n    down: (o)-> @scope.$emit(o.val, @)\n\n  # emits an event when scrolled up past keyframe\n  'upEmit':\n    up: (o)-> @scope.$emit(o.val, @)\n}\n\n.service 'sparkSetup', [ '$interval', '$rootScope', ($interval, $rootScope) ->\n  int = 0\n  @enableInvalidationInterval = (delay = 1000) ->\n    $interval.cancel(int) if int\n    int = $interval (-> $rootScope.$broadcast 'sparkInvalidate'), delay, 0, false\n\n  @disableInvalidationInterval = -> $interval.cancel(int)\n\n  # enable/disable spark-scroll-animate\n  @disableSparkScrollAnimate = false\n\n  # enable/disable spark-scroll\n  @disableSparkScroll = false\n\n  # enable/disable logging\n  @debug = false\n  @\n]\n\n.service 'sparkId', ->\n  @elements = {}\n  @registerElement = (id, element) ->\n    @elements[id] = element\n  @\n\n.directive 'sparkId', [ 'sparkId', (sparkId)->\n  (scope, element, attr) ->\n    sparkId.registerElement(attr.sparkId, element)\n    scope.$on '$destroy', -> delete sparkId.elements[attr.sparkId]\n]\n\ndirectiveFn = ($window, $timeout, sparkFormulas, sparkActionProps, sparkAnimator, sparkId, sparkSetup) ->\n  (scope, element, attr) ->\n\n    hasAnimateAttr = attr.hasOwnProperty('sparkScrollAnimate')  # when using spark-scroll-animate directive animation is enabled\n    isAnimated = hasAnimateAttr\n    return if hasAnimateAttr and sparkSetup.disableSparkScrollAnimate\n    return if !hasAnimateAttr and sparkSetup.disableSparkScroll\n\n    # all callback-related vars\n    callback = false\n    prevRatio = 0\n    minScrollY = 0\n    maxScrollY = 0\n\n    animator = hasAnimateAttr && sparkAnimator.instance()\n    actor = isAnimated && animator.addActor({ context: element[0] })\n    y = 0\n    prevy = 0\n    scrollY = 0\n    animationFrame = AnimationFrame && new AnimationFrame()\n    updating = false\n\n    data = null\n    sparkData = null\n    actionFrames = []\n    actionFrameIdx = -1\n    container = document.documentElement\n\n    triggerElement = element\n\n    if attr.sparkTrigger\n      setTriggerElement = ->\n        if sparkId.elements[attr.sparkTrigger]\n          triggerElement = sparkId.elements[attr.sparkTrigger]\n          recalcFormulas() if recalcFormulas\n        else\n          # aggressively poll for the trigger element if we don't find it (because it's not ready yet)\n          $timeout setTriggerElement, 0, false\n      setTriggerElement()\n\n    actionsUpdate = ->\n\n      d = y - prevy\n\n      if d<0 and actionFrameIdx >= 0  # scroll up: don't apply on page load (only apply on page load for downward movement)\n        idx = if (actionFrameIdx >= actionFrames.length) then actionFrameIdx-1 else actionFrameIdx\n        while (idx >= 0 and y < actionFrames[idx])\n          c = sparkData[actionFrames[idx]]\n\n          for a, o of c.actions\n            for prop in o.props\n              actionProp = sparkActionProps[prop]\n              actionProp.up.call(c, o) if actionProp.up\n\n          actionFrameIdx = --idx\n\n      if d>=0 and actionFrameIdx < actionFrames.length  # scroll down: will apply on page load\n        idx = if (actionFrameIdx < 0) then 0 else actionFrameIdx\n        while (idx < actionFrames.length and y > actionFrames[idx])\n          c = sparkData[actionFrames[idx]]\n\n          for a, o of c.actions\n            for prop in o.props\n              actionProp = sparkActionProps[prop]\n              actionProp.down.call(c, o) if actionProp.down\n\n          actionFrameIdx = ++idx\n\n      prevy = y\n      updating = false\n\n\n    # update for spark-scroll-animate (sparkAnimator-based) animation\n    if attr.hasOwnProperty('sparkScrollEase')\n      update = ->\n        d = scrollY - y\n        ad = Math.abs(d)\n        doCallback() if callback\n        actionsUpdate() # sets updating = false\n        if ad < 1.5\n          y = scrollY\n          animator.update(y)\n        else\n          updating = true\n          y += if ad>8 then d*0.25 else (if d > 0 then 1 else -1) # ease the scroll\n          animator.update(~~y)\n          animationFrame.request(update)\n    else\n      update = ->\n        y = scrollY\n        animator.update(y)\n        doCallback() if callback\n        actionsUpdate() # sets updating = false\n\n\n    # @todo: we could use $parse instead for a more flexible solution but is the addt'l overhead worth it?\n    if attr.hasOwnProperty('sparkScrollCallback')\n      attr.$observe 'sparkScrollCallback', (v) ->\n        callback = scope.$eval(v)\n        callback = false unless _.isFunction(callback)\n        recalcMinMax() unless maxScrollY\n\n\n    recalcMinMax = ->\n      idx = 0\n      for scrY of sparkData\n        scrY = ~~ scrY\n        if idx++\n          if scrY > maxScrollY\n            maxScrollY = scrY\n          else if scrY < minScrollY\n            minScrollY = scrY\n        else\n          maxScrollY = minScrollY = scrY\n\n\n    doCallback = ->\n      ratio = Math.max(0, Math.min((y-minScrollY)/(maxScrollY-minScrollY), 1))\n      callback ratio if ratio != prevRatio\n      prevRatio = ratio\n\n\n    recalcFormulas = ->\n      if sparkData\n        changed = false\n        rect = triggerElement[0].getBoundingClientRect()\n        containerRect = container.getBoundingClientRect()\n\n        for scrY, keyFrame of sparkData when keyFrame.formula\n          newScrY = keyFrame.formula.fn(triggerElement, container, rect, containerRect, keyFrame.formula.offset)\n          if newScrY != ~~scrY\n            changed = true\n            actor.moveKeyframe(~~scrY, newScrY) if keyFrame.anims and hasAnimateAttr # the ~~ is necessary :(\n            sparkData[newScrY] = keyFrame\n            delete sparkData[scrY]\n\n        if changed\n          recalcMinMax() if callback\n          actionFrames = []\n          actionFrames.push(~~scrY) for scrY, kf of sparkData when kf.actionCount\n          actionFrames.sort (a,b) -> a > b\n          onScroll()  # todo: this is checking scrollY unnecessarily\n          # @todo: now are we screwed if something was already passed by ?\n      else\n        parseData()\n        recalcFormulas() if sparkData\n\n\n    parseData = ->\n      return unless data\n\n      actor.removeAllKeyframes() if hasAnimateAttr\n\n      # element ease property\n      elmEase = data.ease || 'linear';\n      delete data.ease\n      animCount = 0\n\n      sparkData = {}\n      actionFrames = []\n\n      # this is used for formula comprehension... a possible performance improvement might\n      # forgo these calculations by adding some option or deferring calculation automatically\n      rect = triggerElement[0].getBoundingClientRect()\n      containerRect = container.getBoundingClientRect()\n\n      for scrY, keyFrame of data\n        keyFrame = _.clone(keyFrame)  # clone for cases when parseData fails and needs to be called again\n        actionCount = 0\n\n        # formula comprehension\n        # when scrollY first char is not a digit, we assume this is a formula\n        c = scrY.charCodeAt(0)\n        if (c < 48 or c > 57)\n          parts = scrY.match(/^(\\w+)(.*)$/)\n          formula =\n            fn: sparkFormulas[parts[1]],\n            offset: ~~parts[2]\n\n          scrY = formula.fn(triggerElement, container, rect, containerRect, formula.offset)\n          if sparkData[scrY]  # silent death for overlapping scrY's (assume that the element isn't ready)\n            console.log \"warning: spark-scroll failed to calculate formulas\", (attr.sparkScroll || attr.sparkScrollAnimate) if sparkSetup.debug\n            sparkData = null\n            return\n\n        # keyframe ease property\n        # (will override or fallback to element ease property)\n        ease = {}\n        kfEase = elmEase\n        if keyFrame.ease?\n          if angular.isObject(keyFrame.ease)\n            ease = keyFrame.ease\n          else\n            kfEase = keyFrame.ease\n          delete keyFrame.ease\n\n        for k,v of keyFrame\n          ksplit = k.split(',')\n\n          # put actions in actions sub-object\n          if sparkActionProps[ksplit[0]] # @todo: rigorous check ? (we assume that if the first action is legit then they all are)\n\n            keyFrame.actions or= { }  # could be more efficient to make actions an array\n            keyFrame.actions[k] = # action object\n              props: ksplit\n              val: v\n            delete keyFrame[k]\n            actionCount++\n\n            # put animations in anims sub-object\n          else # since it's not an action, assume it's an animation property\n\n            # comprehension of array-notation for easing\n            # (will override or fall back to keyframe ease propery as needed)\n            keyFrame.anims or= {}\n            v = [v, kfEase] unless angular.isArray(v)\n            o = {}\n            o[k] = v[1]\n            angular.extend(ease, o)\n\n            keyFrame.anims[k] = v[0]\n            delete keyFrame[k]\n\n        if keyFrame.anims && hasAnimateAttr\n          actor.keyframe(scrY, keyFrame.anims, ease)\n          animCount++\n\n        keyFrame.formula = formula\n        keyFrame.element = element\n        keyFrame.scope = scope\n        keyFrame.actionCount = actionCount\n\n        sparkData[scrY] = keyFrame\n        actionFrames.push(~~scrY) if actionCount\n\n      isAnimated = hasAnimateAttr && !! animCount\n\n      # actors can optionally expose this function to receive a notification that parsing completed\n      actor.finishedAddingKeyframes && actor.finishedAddingKeyframes() if isAnimated\n\n      actionFrames.sort (a,b) -> a > b\n      recalcMinMax() if callback\n\n      y = prevy = scrollY = $window.pageYOffset\n      update() if isAnimated\n      actionsUpdate()\n\n    watchCancel = scope.$watch attr[if hasAnimateAttr then 'sparkScrollAnimate' else 'sparkScroll'], (d) ->\n      return unless d\n      data = _.clone(d)   # clone for cases when parseData fails and needs to be called again\n\n      # useful in angular < v1.3 where one-time binding isn't available\n      if attr.sparkScrollBindOnce? then watchCancel()\n\n      parseData()\n    , true  # deep watch\n\n\n    nonAnimatedUpdate = ->\n      doCallback() if callback\n      actionsUpdate()\n\n\n    # respond to scroll event\n    onScroll = ->\n      scrollY = $window.pageYOffset\n\n      unless updating # debounced update\n        updating = true # in-case multiple scroll events can occur in one frame (possible?)\n        if isAnimated\n            animationFrame.request(update)\n        else\n          y = scrollY\n          animationFrame.request(nonAnimatedUpdate) # @todo: do these calls get queued between frames ?\n\n    # a simple leading:false debounce based on underscore\n    debounce = (func, wait) ->\n      timeout = 0\n      f = ->\n        context = this\n        args = arguments\n        later = ->\n          timeout = null\n          func.apply(context, args)\n\n        clearTimeout(timeout)\n        timeout = setTimeout(later, wait)\n\n      f.cancel = ->\n        clearTimeout(timeout)\n      f\n\n    onInvalidate = debounce(recalcFormulas, 100)\n\n    angular.element($window).on 'scroll', onScroll\n    angular.element($window).on 'resize', onInvalidate\n    angular.element($window).on 'load', onInvalidate\n    scope.$on 'sparkInvalidate', onInvalidate\n\n    scope.$on '$destroy', ->\n      animator.removeActor(actor) if isAnimated\n      angular.element($window).off 'scroll', onScroll\n      angular.element($window).off 'resize', onInvalidate\n      angular.element($window).off 'load', onInvalidate\n      onInvalidate.cancel()\n\n\nangular.module('gilbox.sparkScroll')\n  .directive 'sparkScroll',        ['$window', '$timeout', 'sparkFormulas', 'sparkActionProps', 'sparkAnimator', 'sparkId', 'sparkSetup', directiveFn]\n  .directive 'sparkScrollAnimate', ['$window', '$timeout', 'sparkFormulas', 'sparkActionProps', 'sparkAnimator', 'sparkId', 'sparkSetup', directiveFn]\n"]}